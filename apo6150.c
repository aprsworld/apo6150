#include <16F684.h>
#device adc=10

#FUSES INTRC_IO, NOMCLR, NOWDT, NOPROTECT, PUT, NOIESO, NOFCMEN, NOCPD
#use delay(clock=125000)


#use fast_io(a)
#use fast_io(c)

#define LED_STATUS  PIN_C5
#define VSENSE      PIN_C3
#define VSENSE_ADC  7
#define SW0         PIN_A1
#define SW1         PIN_A2
#define SW2         PIN_A0
#define SW3         PIN_A5
#define SW_OVERRIDE PIN_A4
#define SER_RX      PIN_A3
#define BRIDGE_A    PIN_C1
#define BRIDGE_B    PIN_C4
#define ATE_SIGNAL  PIN_C0
#define VGOOD       PIN_C2

#define EE_LVD       0x00 /* low voltage disconnect */
#define EE_LVR       0x08 /* low voltage re-connect */
#define EE_DELAY     0x10 /* delay before LVD */
#define EE_SN        0x18 /* serial number */
#define EE_MODEL     0x1B /* model. 1=>APO6150 2=>APO6150_24V (R1 = 49.9k) */

/* "serial numbers" that are used for programattically setting various configurations */
#define SN_12V       0x01 /* not used. Was 12V only APO3 */
#define SN_12V_24V   0x02 /* APO6150 that works as 12V or 24V */
#define SN_12V_BRECO 0x03 /* APO3c 12 volt with hysteresis and adjustable on and off voltages ... for Breco ... not tested with APO6150*/

/*
todo:
	more intelligent LED indication
*/


#if 1

/*
off grid APO6150 12/24 volt
EEPROM table for LVD, LVR, off delay, and serial number
generated by the following command:
./apo6150_table 11.5 11.75 12.0 12.25 12.0 12.25 12.5 12.6 1 300 600 1200
*/
#rom 0x2100 = {
        0x01, 0x88, 0x01, 0x91, 0x01, 0x99, 0x01, 0xa2, /* LVD = { 11.50 11.75 12.00 12.25 } volts */
        0x01, 0x99, 0x01, 0xa2, 0x01, 0xaa, 0x01, 0xae, /* LVR = { 12.00 12.25 12.50 12.60 } volts */
        0x00, 0x01, 0x01, 0x2c, 0x02, 0x58, 0x04, 0xb0, /* OFF DELAY = { 1 300 600 1200 } seconds */
        0x00, 0x00, 0x00, 0x02 } /* SERIAL NUMBER is always 2 for APO6150 - signifies auto 12/24 volt */
#endif

#define ON_DELAY_SECONDS 5



/* 1 Hz flag to make decision */
int8 decide_now;

/* configuration globals */
int16 configuration_lvd;
int16 configuration_lvr;
int16 configuration_delay;

static int8 powersaveCount;
static int8 contactorState=255;

static int8 ledBlink; /* set to make LED blink at 1 Hz */


void contactor_on(void) {
	if ( 1 != contactorState ) {
		powersaveCount=1;

		output_low(BRIDGE_A);
		output_high(BRIDGE_B);

		contactorState=1;
	}
}

void contactor_off(void) {
	if ( 0 != contactorState ) {
		powersaveCount=1;

		output_high(BRIDGE_A);
		output_low(BRIDGE_B);

		contactorState=0;
	}
}



#int_timer0
void isr_timer0 (void) {
	decide_now=1;


	if ( 0==powersaveCount ) {
		/* turn off coil to contactor to save power */
		output_low(BRIDGE_A);
		output_low(BRIDGE_B);
	} else {
		powersaveCount--;
	}
	
	if ( ledBlink ) {
		output_toggle(LED_STATUS);
	}	

}

/* take the average of 8 ADC readings */
int16 read_adc_average(int8 channel) {
	int16 value;
	int8 i;

	set_adc_channel(channel); 
	value=0;
	for ( i=0 ; i<8 ; i++ ) {
		value += read_adc(); 
		delay_ms(20);
	}
	/* divide by 8 */
	value = value / 8;

	return value;
}

int16 read_eeprom_int16(int8 address) {
	return make16(read_eeprom(address),read_eeprom(address+1));
}

void get_threshold(void) {
	int8 sw;

	/* read our DIP switches */
	sw=!input(SW0);
	sw=sw<<1;
	sw |= !input(SW1);

	configuration_lvd = read_eeprom_int16(EE_LVD+sw*2);
	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2);

	/* 
	check if we have a 12/24V configuration. If we do, then we check voltage and determine if we have 12 volt or 24 volt battery.
	If 24 volts battery, we double our LVD and LVR set points 
	*/
	if ( SN_12V_24V == read_eeprom(EE_MODEL) && read_adc_average(VSENSE_ADC) > 615 ) {
		configuration_lvd *= 2;
		configuration_lvr *= 2;

		/* turn on LED for 900 milliseconds and then off for 100 ... next we will do normal startup LED flashes */
		restart_wdt();
		output_high(LED_STATUS);
		delay_ms(900);
		output_low(LED_STATUS);
		delay_ms(100);
	}



#ifdef BRECO
	sw=!input(SW2);
	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2);
#endif
}

void get_delay(void) {
	int8 sw;

	/* read our DIP switches */
	sw=!input(SW2);
	sw=sw<<1;
	sw |= !input(SW3);

	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2);

#ifdef BRECO
	sw=!input(SW3);
	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2);
#endif
}



/* setup the PIC */
void init_hardware(void) {
	/* setup a very slow oscillator - apo3c draws 1.32mA */
	setup_oscillator(OSC_125KHZ);
	setup_wdt(WDT_OFF);

//	setup_wdt(WDT_2304MS);
//	setup_wdt(WDT_2304MS | WDT_ON);

	restart_wdt();

	/* setup analog to digital converter */
	setup_adc_ports(sAN7); /* battery input */
	setup_adc(ADC_CLOCK_INTERNAL);

	/* turn analog comparator off */
	setup_comparator(NC_NC_NC_NC);
	setup_vref(FALSE);

	/* set the direction of port_a */
	set_tris_a(0b00111111);
    /*           76543210 */

	/* setup pullups for switches (individually addressable) */
	port_a_pullups(0b00111111);

	/* set the direction of port_c */
	set_tris_c(0b00001001);
    /*           76543210 */


	/* setup our timer to be 1.048576 second */
	setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_128);
	enable_interrupts(INT_TIMER0);
	enable_interrupts(GLOBAL);

	/* read our configuration from EEPROM */
	get_threshold();
	get_delay();

	/* initial values */
	output_low(LED_STATUS);
	output_low(VGOOD);
	decide_now=1;
}

void led_flash(int8 n) {
	int8 i;
	for ( i=0 ; i<n ; i++ ) {
		restart_wdt();
		output_high(LED_STATUS);
		delay_ms(500);
		output_low(LED_STATUS);
		delay_ms(500);
	}
}

void main(void) {
	int16 adc;

	int8  on_delay;
	int16 off_delay;
	int1 power;

	/* initialize hardware */
	init_hardware();


	on_delay=ON_DELAY_SECONDS;
	off_delay=configuration_delay;

	/* flash the LED 5 times on startup ... non-hysteresis APOx firmware flashes 10 times on startup */
	led_flash(5);

	power=0;

	/* main loop */
	for ( ; ; ) {
		restart_wdt();
		
		/* determine contactor state for next loop */
		if ( decide_now ) {
			decide_now=0;

			adc=read_adc_average(VSENSE_ADC);
	
			if ( adc > configuration_lvd )
				output_high(VGOOD);
			else
				output_low(VGOOD);
	
	
			if ( adc > configuration_lvr ) {
				if ( on_delay > 0 ) {
					on_delay--;
				} else {
					power=1;
					output_low(LED_STATUS);
				}
			} else {
				on_delay = ON_DELAY_SECONDS; /* 5 seconds before re-connecting */
			}
		
			if ( adc < configuration_lvd ) {
				if ( off_delay > 0 ) {
					off_delay--;
					output_high(LED_STATUS);
				} else {
					power=0;
					output_low(LED_STATUS);
				}
			} else {
				off_delay = configuration_delay;
			}
			restart_wdt();
		}


		/* set the contactor based on previous decision and override switch */
		if ( 1==power ) {
			/* should be on based on voltage / time */
			contactor_on();

			/* no LED blinking required */
			ledBlink=0;
		} else if ( ! input(SW_OVERRIDE) ) {
			/* shouldn't be on based on voltage / time, but override switch has us on */
			contactor_on();

			/* blink LED to indicate we are overriden */
			ledBlink=1;
		} else {
			/* shouldn't be on based on voltage / time */
			contactor_off();

			/* no LED blinking required */
			ledBlink=0;
		}


	}
}
