CCS PCM C Compiler, Version 4.090, 47882               08-Nov-18 11:45

               Filename: apo6150.lst

               ROM used: 441 words (25%)
                         Largest free fragment is 1351
               RAM used: 29 (25%) at main() level
                         34 (29%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  01
0002:  MOVWF  0A
0003:  GOTO   138
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  25
0007:  SWAPF  03,W
0008:  MOVWF  26
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  25
000C:  SWAPF  03,W
000D:  MOVWF  26
000E:  BSF    26.1
000F:  MOVF   0A,W
0010:  MOVWF  2D
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  25,F
0014:  MOVF   04,W
0015:  MOVWF  27
0016:  MOVF   20,W
0017:  MOVWF  28
0018:  MOVF   21,W
0019:  MOVWF  29
001A:  MOVF   22,W
001B:  MOVWF  2A
001C:  MOVF   23,W
001D:  MOVWF  2B
001E:  MOVF   24,W
001F:  MOVWF  2C
0020:  BCF    03.5
0021:  BTFSS  0B.5
0022:  GOTO   025
0023:  BTFSC  0B.2
0024:  GOTO   03A
0025:  MOVF   27,W
0026:  MOVWF  04
0027:  MOVF   28,W
0028:  MOVWF  20
0029:  MOVF   29,W
002A:  MOVWF  21
002B:  MOVF   2A,W
002C:  MOVWF  22
002D:  MOVF   2B,W
002E:  MOVWF  23
002F:  MOVF   2C,W
0030:  MOVWF  24
0031:  MOVF   2D,W
0032:  MOVWF  0A
0033:  SWAPF  26,W
0034:  MOVWF  03
0035:  BCF    03.5
0036:  SWAPF  25,W
0037:  BTFSC  26.1
0038:  BSF    03.5
0039:  RETFIE
.................... #include <16F684.h> 
.................... //////// Standard Header file for the PIC16F684 device //////////////// 
.................... #device PIC16F684 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES INTRC_IO, NOMCLR, NOWDT, NOPROTECT, PUT, NOIESO, NOFCMEN, NOCPD 
.................... #use delay(clock=125000) 
*
008E:  MOVLW  3F
008F:  MOVWF  04
0090:  MOVF   00,W
0091:  BTFSC  03.2
0092:  GOTO   099
0093:  MOVLW  09
0094:  MOVWF  20
0095:  DECFSZ 20,F
0096:  GOTO   095
0097:  DECFSZ 00,F
0098:  GOTO   093
0099:  RETLW  00
....................  
....................  
.................... #use fast_io(a) 
.................... #use fast_io(c) 
....................  
.................... #define LED_STATUS  PIN_C5 
.................... #define VSENSE      PIN_C3 
.................... #define VSENSE_ADC  7 
.................... #define SW0         PIN_A1 
.................... #define SW1         PIN_A2 
.................... #define SW2         PIN_A0 
.................... #define SW3         PIN_A5 
.................... #define SW_OVERRIDE PIN_A4 
.................... #define SER_RX      PIN_A3 
.................... #define BRIDGE_A    PIN_C1 
.................... #define BRIDGE_B    PIN_C4 
.................... #define ATE_SIGNAL  PIN_C0 
.................... #define VGOOD       PIN_C2 
....................  
.................... #define EE_LVD       0x00 /* low voltage disconnect */ 
.................... #define EE_LVR       0x08 /* low voltage re-connect */ 
.................... #define EE_DELAY     0x10 /* delay before LVD */ 
.................... #define EE_SN        0x18 /* serial number */ 
.................... #define EE_MODEL     0x1B /* model. 1=>APO6150 2=>APO6150_24V (R1 = 49.9k) */ 
....................  
.................... /* "serial numbers" that are used for programattically setting various configurations */ 
.................... #define SN_12V       0x01 /* standard APO3c 12 volt only */ 
.................... #define SN_12V_24V   0x02 /* solid state APO3c (with R1=49.9k) that works as 12V or 24V */ 
.................... #define SN_12V_BRECO 0x03 /* APO3c 12 volt with hysteresis and adjustable on and off voltages ... for Breco *./ 
....................  
.................... /* 
.................... todo: 
.................... 	more intelligent LED indication 
.................... */ 
....................  
....................  
.................... #if 1 
....................  
.................... /* 
.................... off grid APO6150 12/24 volt 
.................... EEPROM table for LVD, LVR, off delay, and serial number 
.................... generated by the following command: 
.................... ./apo6150_table 11.5 11.75 12.0 12.25 12.0 12.25 12.5 12.6 1 300 600 1200 
.................... */ 
.................... #rom 0x2100 = { 
....................         0x01, 0x88, 0x01, 0x91, 0x01, 0x99, 0x01, 0xa2, /* LVD = { 11.50 11.75 12.00 12.25 } volts */ 
....................         0x01, 0x99, 0x01, 0xa2, 0x01, 0xaa, 0x01, 0xae, /* LVR = { 12.00 12.25 12.50 12.60 } volts */ 
....................         0x00, 0x01, 0x01, 0x2c, 0x02, 0x58, 0x04, 0xb0, /* OFF DELAY = { 1 300 600 1200 } seconds */ 
....................         0x00, 0x00, 0x00, 0x02 } /* SERIAL NUMBER is always 2 for APO6150 - signifies auto 12/24 volt */ 
.................... #endif 
....................  
.................... #define ON_DELAY_SECONDS 5 
....................  
....................  
....................  
.................... /* 1 Hz flag to make decision */ 
.................... int8 decide_now; 
....................  
.................... /* configuration globals */ 
.................... int16 configuration_lvd; 
.................... int16 configuration_lvr; 
.................... int16 configuration_delay; 
....................  
.................... static int8 powersaveCount; 
*
0148:  CLRF   35
....................  
.................... #inline 
.................... void start_timeout_count(void) { 
.................... 	/* shut off coils after 1 to 2 seconds */ 
.................... 	powersaveCount=2; 
*
012E:  MOVLW  02
012F:  MOVWF  35
*
0133:  MOVLW  02
0134:  MOVWF  35
.................... } 
....................  
.................... void contactor_on(void) { 
.................... 	start_timeout_count(); 
....................  
.................... 	output_high(BRIDGE_A); 
*
0130:  BSF    07.1
.................... 	output_low(BRIDGE_B); 
0131:  BCF    07.4
.................... } 
0132:  GOTO   16B (RETURN)
....................  
.................... void contactor_off(void) { 
.................... 	start_timeout_count(); 
....................  
.................... 	output_low(BRIDGE_A); 
*
0135:  BCF    07.1
.................... 	output_high(BRIDGE_B); 
0136:  BSF    07.4
.................... } 
0137:  GOTO   16D (RETURN)
....................  
....................  
....................  
.................... #int_timer0 
.................... void isr_timer0 (void) { 
.................... //	output_toggle(LED_STATUS); 
....................  
....................  
.................... 	decide_now=1; 
*
003A:  MOVLW  01
003B:  MOVWF  2E
....................  
....................  
.................... 	if ( 0==powersaveCount ) { 
003C:  MOVF   35,F
003D:  BTFSS  03.2
003E:  GOTO   042
.................... 		/* turn off coil to contactor to save power */ 
.................... 		output_low(BRIDGE_A); 
003F:  BCF    07.1
.................... 		output_low(BRIDGE_B); 
0040:  BCF    07.4
.................... 	} else { 
0041:  GOTO   043
.................... 		powersaveCount--; 
0042:  DECF   35,F
.................... 	} 
.................... } 
....................  
.................... /* take the average of 8 ADC readings */ 
0043:  BCF    0B.2
0044:  BCF    0A.3
0045:  GOTO   025
.................... int16 read_adc_average(int8 channel) { 
.................... 	int16 value; 
.................... 	int8 i; 
....................  
.................... 	set_adc_channel(channel);  
*
0060:  RLF    3E,W
0061:  MOVWF  20
0062:  RLF    20,F
0063:  MOVLW  FC
0064:  ANDWF  20,F
0065:  MOVF   1F,W
0066:  ANDLW  C3
0067:  IORWF  20,W
0068:  MOVWF  1F
.................... 	value=0; 
0069:  CLRF   40
006A:  CLRF   3F
.................... 	for ( i=0 ; i<8 ; i++ ) { 
006B:  CLRF   41
006C:  MOVF   41,W
006D:  SUBLW  07
006E:  BTFSS  03.0
006F:  GOTO   081
.................... 		value += read_adc();  
0070:  BSF    1F.1
0071:  BTFSC  1F.1
0072:  GOTO   071
0073:  BSF    03.5
0074:  MOVF   1E,W
0075:  BCF    03.5
0076:  ADDWF  3F,F
0077:  MOVF   1E,W
0078:  BTFSC  03.0
0079:  INCFSZ 1E,W
007A:  ADDWF  40,F
.................... 		delay_ms(20); 
007B:  MOVLW  D0
007C:  MOVWF  20
007D:  DECFSZ 20,F
007E:  GOTO   07D
.................... 	} 
007F:  INCF   41,F
0080:  GOTO   06C
.................... 	/* divide by 8 */ 
.................... 	value = value / 8; 
0081:  RRF    40,F
0082:  RRF    3F,F
0083:  RRF    40,F
0084:  RRF    3F,F
0085:  RRF    40,F
0086:  RRF    3F,F
0087:  MOVLW  1F
0088:  ANDWF  40,F
....................  
.................... 	return value; 
0089:  MOVF   3F,W
008A:  MOVWF  21
008B:  MOVF   40,W
008C:  MOVWF  22
.................... } 
008D:  RETLW  00
....................  
.................... int16 read_eeprom_int16(int8 address) { 
.................... 	return make16(read_eeprom(address),read_eeprom(address+1)); 
*
0046:  MOVF   3F,W
0047:  BSF    03.5
0048:  MOVWF  1B
0049:  BCF    1C.7
004A:  BSF    1C.0
004B:  MOVF   1A,W
004C:  BCF    03.5
004D:  MOVWF  40
004E:  MOVLW  01
004F:  ADDWF  3F,W
0050:  MOVWF  41
0051:  MOVF   41,W
0052:  BSF    03.5
0053:  MOVWF  1B
0054:  BCF    1C.7
0055:  BSF    1C.0
0056:  MOVF   1A,W
0057:  BCF    03.5
0058:  MOVWF  41
0059:  MOVF   40,W
005A:  MOVWF  23
005B:  MOVF   41,W
005C:  MOVWF  21
005D:  MOVF   23,W
005E:  MOVWF  22
.................... } 
005F:  RETLW  00
....................  
.................... void get_threshold(void) { 
.................... 	int8 sw; 
....................  
.................... 	/* read our DIP switches */ 
.................... 	sw=!input(SW0); 
*
00C4:  CLRF   3D
00C5:  BTFSS  05.1
00C6:  INCF   3D,F
.................... 	sw=sw<<1; 
00C7:  BCF    03.0
00C8:  RLF    3D,F
.................... 	sw |= !input(SW1); 
00C9:  MOVLW  00
00CA:  BTFSS  05.2
00CB:  MOVLW  01
00CC:  IORWF  3D,F
....................  
.................... 	configuration_lvd = read_eeprom_int16(EE_LVD+sw*2); 
00CD:  BCF    03.0
00CE:  RLF    3D,W
00CF:  MOVWF  3E
00D0:  MOVWF  3F
00D1:  CALL   046
00D2:  MOVF   22,W
00D3:  MOVWF  30
00D4:  MOVF   21,W
00D5:  MOVWF  2F
.................... 	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2); 
00D6:  BCF    03.0
00D7:  RLF    3D,W
00D8:  ADDLW  08
00D9:  MOVWF  3E
00DA:  MOVWF  3F
00DB:  CALL   046
00DC:  MOVF   22,W
00DD:  MOVWF  32
00DE:  MOVF   21,W
00DF:  MOVWF  31
....................  
.................... 	/*  
.................... 	check if we have an APO3c24. If we do, then we check voltage and determine if we have 12 volt or 24 volt battery. 
.................... 	If 24 volts battery, , we double our LVD and LVR set points  
.................... 	*/ 
.................... 	if ( SN_12V_24V == read_eeprom(EE_MODEL) && read_adc_average(VSENSE_ADC) > 615 ) { 
00E0:  MOVLW  1B
00E1:  BSF    03.5
00E2:  MOVWF  1B
00E3:  BCF    1C.7
00E4:  BSF    1C.0
00E5:  MOVF   1A,W
00E6:  SUBLW  02
00E7:  BTFSS  03.2
00E8:  GOTO   114
00E9:  MOVLW  07
00EA:  BCF    03.5
00EB:  MOVWF  3E
00EC:  CALL   060
00ED:  MOVF   22,W
00EE:  MOVWF  3F
00EF:  MOVF   21,W
00F0:  MOVWF  3E
00F1:  MOVF   3F,W
00F2:  SUBLW  01
00F3:  BTFSS  03.0
00F4:  GOTO   0F7
00F5:  BSF    03.5
00F6:  GOTO   114
00F7:  XORLW  FF
00F8:  BTFSS  03.2
00F9:  GOTO   100
00FA:  MOVF   3E,W
00FB:  SUBLW  67
00FC:  BTFSS  03.0
00FD:  GOTO   100
00FE:  BSF    03.5
00FF:  GOTO   114
.................... 		configuration_lvd *= 2; 
0100:  BCF    03.0
0101:  RLF    2F,F
0102:  RLF    30,F
.................... 		configuration_lvr *= 2; 
0103:  BCF    03.0
0104:  RLF    31,F
0105:  RLF    32,F
....................  
.................... 		/* turn on LED for 900 milliseconds and then off for 100 ... next we will do normal startup LED flashes */ 
.................... 		restart_wdt(); 
0106:  CLRWDT
.................... 		output_high(LED_STATUS); 
0107:  BSF    07.5
.................... 		delay_ms(900); 
0108:  MOVLW  04
0109:  MOVWF  3E
010A:  MOVLW  E1
010B:  MOVWF  3F
010C:  CALL   08E
010D:  DECFSZ 3E,F
010E:  GOTO   10A
.................... 		output_low(LED_STATUS); 
010F:  BCF    07.5
.................... 		delay_ms(100); 
0110:  MOVLW  64
0111:  MOVWF  3F
0112:  CALL   08E
0113:  BSF    03.5
0114:  NOP
.................... 	} 
....................  
....................  
....................  
.................... #ifdef BRECO 
.................... 	sw=!input(SW2); 
.................... 	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2); 
.................... #endif 
.................... } 
....................  
.................... void get_delay(void) { 
.................... 	int8 sw; 
....................  
.................... 	/* read our DIP switches */ 
.................... 	sw=!input(SW2); 
0115:  BCF    03.5
0116:  CLRF   3D
0117:  BTFSS  05.0
0118:  INCF   3D,F
.................... 	sw=sw<<1; 
0119:  BCF    03.0
011A:  RLF    3D,F
.................... 	sw |= !input(SW3); 
011B:  MOVLW  00
011C:  BTFSS  05.5
011D:  MOVLW  01
011E:  IORWF  3D,F
....................  
.................... 	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2); 
011F:  BCF    03.0
0120:  RLF    3D,W
0121:  ADDLW  10
0122:  MOVWF  3E
0123:  MOVWF  3F
0124:  CALL   046
0125:  MOVF   22,W
0126:  MOVWF  34
0127:  MOVF   21,W
0128:  MOVWF  33
....................  
.................... #ifdef BRECO 
.................... 	sw=!input(SW3); 
.................... 	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2); 
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /* setup the PIC */ 
.................... void init_hardware(void) { 
.................... 	/* setup a very slow oscillator - apo3c draws 1.32mA */ 
.................... 	setup_oscillator(OSC_125KHZ); 
*
009A:  MOVLW  11
009B:  BSF    03.5
009C:  MOVWF  0F
009D:  MOVF   0F,W
.................... 	setup_wdt(WDT_OFF); 
009E:  BCF    03.5
009F:  BCF    18.0
....................  
.................... //	setup_wdt(WDT_2304MS); 
.................... //	setup_wdt(WDT_2304MS | WDT_ON); 
....................  
.................... 	restart_wdt(); 
00A0:  CLRWDT
....................  
.................... 	/* setup analog to digital converter */ 
.................... 	setup_adc_ports(sAN7); /* battery input */ 
00A1:  BCF    1F.6
00A2:  MOVLW  80
00A3:  BSF    03.5
00A4:  MOVWF  11
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
00A5:  BSF    1F.4
00A6:  BSF    1F.5
00A7:  BCF    1F.6
00A8:  BCF    03.5
00A9:  BSF    1F.7
00AA:  BSF    1F.0
....................  
.................... 	/* turn analog comparator off */ 
.................... 	setup_comparator(NC_NC_NC_NC); 
00AB:  CLRF   1A
00AC:  MOVLW  07
00AD:  MOVWF  19
00AE:  BSF    03.5
00AF:  MOVF   05,W
00B0:  MOVWF  05
00B1:  BCF    03.5
00B2:  MOVF   19,W
00B3:  BCF    0C.3
.................... 	setup_vref(FALSE); 
00B4:  BSF    03.5
00B5:  CLRF   19
....................  
.................... 	/* set the direction of port_a */ 
.................... 	set_tris_a(0b00111111); 
00B6:  MOVLW  3F
00B7:  MOVWF  05
.................... 	/* setup pullups for switches (individually addressable) */ 
.................... 	port_a_pullups(0b00111111); 
00B8:  MOVWF  15
00B9:  BCF    01.7
.................... 	/* set the direction of port_c */ 
.................... 	set_tris_c(0b00001001); 
00BA:  MOVLW  09
00BB:  MOVWF  07
....................  
.................... 	/* setup our timer to be 1.048576 second */ 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_128); 
00BC:  MOVF   01,W
00BD:  ANDLW  C0
00BE:  IORLW  06
00BF:  MOVWF  01
.................... 	enable_interrupts(INT_TIMER0); 
00C0:  BCF    03.5
00C1:  BSF    0B.5
.................... 	enable_interrupts(GLOBAL); 
00C2:  MOVLW  C0
00C3:  IORWF  0B,F
....................  
.................... 	/* read our configuration from EEPROM */ 
.................... 	get_threshold(); 
.................... 	get_delay(); 
....................  
.................... 	/* initial values */ 
.................... 	output_low(LED_STATUS); 
*
0129:  BCF    07.5
.................... 	output_low(VGOOD); 
012A:  BCF    07.2
.................... 	decide_now=1; 
012B:  MOVLW  01
012C:  MOVWF  2E
.................... } 
012D:  GOTO   14A (RETURN)
....................  
....................  
....................  
.................... void main(void) { 
*
0138:  CLRF   04
0139:  MOVLW  1F
013A:  ANDWF  03,F
013B:  MOVLW  11
013C:  BSF    03.5
013D:  MOVWF  0F
013E:  MOVF   0F,W
013F:  BCF    03.5
0140:  BCF    1F.6
0141:  MOVLW  00
0142:  BSF    03.5
0143:  MOVWF  11
0144:  BCF    03.5
0145:  CLRF   1A
0146:  MOVLW  07
0147:  MOVWF  19
.................... 	int8 i; 
.................... 	int16 adc; 
....................  
.................... 	int8  on_delay; 
.................... 	int16 off_delay; 
.................... 	int1 power; 
....................  
.................... 	/* initialize hardware */ 
.................... 	init_hardware(); 
*
0149:  GOTO   09A
....................  
....................  
.................... 	on_delay=ON_DELAY_SECONDS; 
014A:  MOVLW  05
014B:  MOVWF  39
.................... 	off_delay=configuration_delay; 
014C:  MOVF   34,W
014D:  MOVWF  3B
014E:  MOVF   33,W
014F:  MOVWF  3A
.................... 	 
....................  
....................  
....................  
.................... 	/* flash the LED 5 times on startup ... non-hysteresis APO3C firmware flashes 10 times on startup */ 
.................... 	for ( i=0 ; i<5 ; i++ ) { 
0150:  CLRF   36
0151:  MOVF   36,W
0152:  SUBLW  04
0153:  BTFSS  03.0
0154:  GOTO   160
.................... 		restart_wdt(); 
0155:  CLRWDT
.................... 		output_high(LED_STATUS); 
0156:  BSF    07.5
.................... 		delay_ms(200); 
0157:  MOVLW  C8
0158:  MOVWF  3F
0159:  CALL   08E
.................... 		output_low(LED_STATUS); 
015A:  BCF    07.5
.................... 		delay_ms(200); 
015B:  MOVLW  C8
015C:  MOVWF  3F
015D:  CALL   08E
.................... 	} 
015E:  INCF   36,F
015F:  GOTO   151
....................  
.................... 	power=0; 
0160:  BCF    3C.0
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
0161:  CLRWDT
....................  
.................... 		/* actually flip the power relay */ 
.................... 		if ( 1==power || ! input(SW_OVERRIDE) ) { 
0162:  MOVLW  00
0163:  BTFSC  3C.0
0164:  MOVLW  01
0165:  SUBLW  01
0166:  BTFSC  03.2
0167:  GOTO   16A
0168:  BTFSC  05.4
0169:  GOTO   16C
.................... 			contactor_on(); 
016A:  GOTO   12E
.................... 		} else { 
016B:  GOTO   16D
.................... 			contactor_off(); 
016C:  GOTO   133
.................... 		} 
....................  
.................... 		if ( decide_now ) { 
016D:  MOVF   2E,F
016E:  BTFSC  03.2
016F:  GOTO   1B7
.................... 			decide_now=0; 
0170:  CLRF   2E
....................  
.................... 			adc=read_adc_average(VSENSE_ADC); 
0171:  MOVLW  07
0172:  MOVWF  3E
0173:  CALL   060
0174:  MOVF   22,W
0175:  MOVWF  38
0176:  MOVF   21,W
0177:  MOVWF  37
.................... 	 
.................... 			if ( adc > configuration_lvd ) 
0178:  MOVF   30,W
0179:  SUBWF  38,W
017A:  BTFSS  03.0
017B:  GOTO   184
017C:  BTFSS  03.2
017D:  GOTO   182
017E:  MOVF   37,W
017F:  SUBWF  2F,W
0180:  BTFSC  03.0
0181:  GOTO   184
.................... 				output_high(VGOOD); 
0182:  BSF    07.2
.................... 			else 
0183:  GOTO   185
.................... 				output_low(VGOOD); 
0184:  BCF    07.2
.................... 	 
.................... 	 
.................... 			if ( adc > configuration_lvr ) { 
0185:  MOVF   32,W
0186:  SUBWF  38,W
0187:  BTFSS  03.0
0188:  GOTO   197
0189:  BTFSS  03.2
018A:  GOTO   18F
018B:  MOVF   37,W
018C:  SUBWF  31,W
018D:  BTFSC  03.0
018E:  GOTO   197
.................... 				if ( on_delay > 0 ) { 
018F:  MOVF   39,F
0190:  BTFSC  03.2
0191:  GOTO   194
.................... 					on_delay--; 
0192:  DECF   39,F
.................... 				} else { 
0193:  GOTO   196
.................... 					power=1; 
0194:  BSF    3C.0
.................... 					output_low(LED_STATUS); 
0195:  BCF    07.5
.................... 				} 
.................... 			} else { 
0196:  GOTO   199
.................... 				on_delay = 5; /* 5 seconds before re-connecting */ 
0197:  MOVLW  05
0198:  MOVWF  39
.................... 			} 
.................... 		 
.................... 			if ( adc < configuration_lvd ) { 
0199:  MOVF   38,W
019A:  SUBWF  30,W
019B:  BTFSS  03.0
019C:  GOTO   1B2
019D:  BTFSS  03.2
019E:  GOTO   1A3
019F:  MOVF   2F,W
01A0:  SUBWF  37,W
01A1:  BTFSC  03.0
01A2:  GOTO   1B2
.................... 				if ( off_delay > 0 ) { 
01A3:  MOVF   3A,F
01A4:  BTFSS  03.2
01A5:  GOTO   1A9
01A6:  MOVF   3B,F
01A7:  BTFSC  03.2
01A8:  GOTO   1AF
.................... 					off_delay--; 
01A9:  MOVF   3A,W
01AA:  BTFSC  03.2
01AB:  DECF   3B,F
01AC:  DECF   3A,F
.................... 					output_high(LED_STATUS); 
01AD:  BSF    07.5
.................... 				} else { 
01AE:  GOTO   1B1
.................... 					power=0; 
01AF:  BCF    3C.0
.................... 					output_low(LED_STATUS); 
01B0:  BCF    07.5
.................... 				} 
.................... 			} else { 
01B1:  GOTO   1B6
.................... 				off_delay = configuration_delay; 
01B2:  MOVF   34,W
01B3:  MOVWF  3B
01B4:  MOVF   33,W
01B5:  MOVWF  3A
.................... 			} 
.................... 			restart_wdt(); 
01B6:  CLRWDT
.................... 		} 
.................... 	} 
01B7:  GOTO   161
.................... } 
01B8:  GOTO   1B8

Configuration Fuses:
   Word  1: 30D4   INTRC_IO NOPROTECT NOBROWNOUT NOMCLR NOCPD NOWDT NOPUT NOIESO NOFCMEN

ROM data:
002100: 0001 0088 0001 0091 0001 0099 0001 00A2 
002108: 0001 0099 0001 00A2 0001 00AA 0001 00AE 
002110: 0000 0001 0001 002C 0002 0058 0004 00B0 
002118: 0000 0000 0000 0002 
