CCS PCM C Compiler, Version 4.090, 47882               09-Nov-18 11:00

               Filename: apo6150.lst

               ROM used: 475 words (27%)
                         Largest free fragment is 1317
               RAM used: 30 (26%) at main() level
                         35 (30%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
0000:  NOP
0001:  MOVLW  01
0002:  MOVWF  0A
0003:  GOTO   15E
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  25
0007:  SWAPF  03,W
0008:  MOVWF  26
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  25
000C:  SWAPF  03,W
000D:  MOVWF  26
000E:  BSF    26.1
000F:  MOVF   0A,W
0010:  MOVWF  2D
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  25,F
0014:  MOVF   04,W
0015:  MOVWF  27
0016:  MOVF   20,W
0017:  MOVWF  28
0018:  MOVF   21,W
0019:  MOVWF  29
001A:  MOVF   22,W
001B:  MOVWF  2A
001C:  MOVF   23,W
001D:  MOVWF  2B
001E:  MOVF   24,W
001F:  MOVWF  2C
0020:  BCF    03.5
0021:  BTFSS  0B.5
0022:  GOTO   025
0023:  BTFSC  0B.2
0024:  GOTO   03A
0025:  MOVF   27,W
0026:  MOVWF  04
0027:  MOVF   28,W
0028:  MOVWF  20
0029:  MOVF   29,W
002A:  MOVWF  21
002B:  MOVF   2A,W
002C:  MOVWF  22
002D:  MOVF   2B,W
002E:  MOVWF  23
002F:  MOVF   2C,W
0030:  MOVWF  24
0031:  MOVF   2D,W
0032:  MOVWF  0A
0033:  SWAPF  26,W
0034:  MOVWF  03
0035:  BCF    03.5
0036:  SWAPF  25,W
0037:  BTFSC  26.1
0038:  BSF    03.5
0039:  RETFIE
.................... #include <16F684.h> 
.................... //////// Standard Header file for the PIC16F684 device //////////////// 
.................... #device PIC16F684 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES INTRC_IO, NOMCLR, NOWDT, NOPROTECT, PUT, NOIESO, NOFCMEN, NOCPD 
.................... #use delay(clock=125000) 
*
0093:  MOVLW  41
0094:  MOVWF  04
0095:  MOVF   00,W
0096:  BTFSC  03.2
0097:  GOTO   09E
0098:  MOVLW  09
0099:  MOVWF  20
009A:  DECFSZ 20,F
009B:  GOTO   09A
009C:  DECFSZ 00,F
009D:  GOTO   098
009E:  RETLW  00
....................  
....................  
.................... #use fast_io(a) 
.................... #use fast_io(c) 
....................  
.................... #define LED_STATUS  PIN_C5 
.................... #define VSENSE      PIN_C3 
.................... #define VSENSE_ADC  7 
.................... #define SW0         PIN_A1 
.................... #define SW1         PIN_A2 
.................... #define SW2         PIN_A0 
.................... #define SW3         PIN_A5 
.................... #define SW_OVERRIDE PIN_A4 
.................... #define SER_RX      PIN_A3 
.................... #define BRIDGE_A    PIN_C1 
.................... #define BRIDGE_B    PIN_C4 
.................... #define ATE_SIGNAL  PIN_C0 
.................... #define VGOOD       PIN_C2 
....................  
.................... #define EE_LVD       0x00 /* low voltage disconnect */ 
.................... #define EE_LVR       0x08 /* low voltage re-connect */ 
.................... #define EE_DELAY     0x10 /* delay before LVD */ 
.................... #define EE_SN        0x18 /* serial number */ 
.................... #define EE_MODEL     0x1B /* model. 1=>APO6150 2=>APO6150_24V (R1 = 49.9k) */ 
....................  
.................... /* "serial numbers" that are used for programattically setting various configurations */ 
.................... #define SN_12V       0x01 /* not used. Was 12V only APO3 */ 
.................... #define SN_12V_24V   0x02 /* APO6150 that works as 12V or 24V */ 
.................... #define SN_12V_BRECO 0x03 /* APO3c 12 volt with hysteresis and adjustable on and off voltages ... for Breco ... not tested with APO6150*/ 
....................  
.................... /* 
.................... todo: 
.................... 	more intelligent LED indication 
.................... */ 
....................  
....................  
.................... #if 1 
....................  
.................... /* 
.................... off grid APO6150 12/24 volt 
.................... EEPROM table for LVD, LVR, off delay, and serial number 
.................... generated by the following command: 
.................... ./apo6150_table 11.5 11.75 12.0 12.25 12.0 12.25 12.5 12.6 1 300 600 1200 
.................... */ 
.................... #rom 0x2100 = { 
....................         0x01, 0x88, 0x01, 0x91, 0x01, 0x99, 0x01, 0xa2, /* LVD = { 11.50 11.75 12.00 12.25 } volts */ 
....................         0x01, 0x99, 0x01, 0xa2, 0x01, 0xaa, 0x01, 0xae, /* LVR = { 12.00 12.25 12.50 12.60 } volts */ 
....................         0x00, 0x01, 0x01, 0x2c, 0x02, 0x58, 0x04, 0xb0, /* OFF DELAY = { 1 300 600 1200 } seconds */ 
....................         0x00, 0x00, 0x00, 0x02 } /* SERIAL NUMBER is always 2 for APO6150 - signifies auto 12/24 volt */ 
.................... #endif 
....................  
.................... #define ON_DELAY_SECONDS 5 
....................  
....................  
....................  
.................... /* 1 Hz flag to make decision */ 
.................... int8 decide_now; 
....................  
.................... /* configuration globals */ 
.................... int16 configuration_lvd; 
.................... int16 configuration_lvr; 
.................... int16 configuration_delay; 
....................  
.................... static int8 powersaveCount; 
*
016E:  CLRF   35
.................... static int8 contactorState=255; 
016F:  MOVLW  FF
0170:  MOVWF  36
....................  
.................... static int8 ledBlink; /* set to make LED blink at 1 Hz */ 
0171:  CLRF   37
....................  
....................  
.................... void contactor_on(void) { 
.................... 	if ( 1 != contactorState ) { 
*
014C:  DECFSZ 36,W
014D:  GOTO   14F
014E:  GOTO   154
.................... 		powersaveCount=1; 
014F:  MOVLW  01
0150:  MOVWF  35
....................  
.................... 		output_low(BRIDGE_A); 
0151:  BCF    07.1
.................... 		output_high(BRIDGE_B); 
0152:  BSF    07.4
....................  
.................... 		contactorState=1; 
0153:  MOVWF  36
.................... 	} 
.................... } 
0154:  RETLW  00
....................  
.................... void contactor_off(void) { 
.................... 	if ( 0 != contactorState ) { 
0155:  MOVF   36,F
0156:  BTFSC  03.2
0157:  GOTO   15D
.................... 		powersaveCount=1; 
0158:  MOVLW  01
0159:  MOVWF  35
....................  
.................... 		output_high(BRIDGE_A); 
015A:  BSF    07.1
.................... 		output_low(BRIDGE_B); 
015B:  BCF    07.4
....................  
.................... 		contactorState=0; 
015C:  CLRF   36
.................... 	} 
.................... } 
015D:  GOTO   18E (RETURN)
....................  
....................  
....................  
.................... #int_timer0 
.................... void isr_timer0 (void) { 
.................... 	decide_now=1; 
*
003A:  MOVLW  01
003B:  MOVWF  2E
....................  
....................  
.................... 	if ( 0==powersaveCount ) { 
003C:  MOVF   35,F
003D:  BTFSS  03.2
003E:  GOTO   042
.................... 		/* turn off coil to contactor to save power */ 
.................... 		output_low(BRIDGE_A); 
003F:  BCF    07.1
.................... 		output_low(BRIDGE_B); 
0040:  BCF    07.4
.................... 	} else { 
0041:  GOTO   043
.................... 		powersaveCount--; 
0042:  DECF   35,F
.................... 	} 
.................... 	 
.................... 	if ( ledBlink ) { 
0043:  MOVF   37,F
0044:  BTFSC  03.2
0045:  GOTO   048
.................... 		output_toggle(LED_STATUS); 
0046:  MOVLW  20
0047:  XORWF  07,F
.................... 	}	 
....................  
.................... } 
....................  
.................... /* take the average of 8 ADC readings */ 
0048:  BCF    0B.2
0049:  BCF    0A.3
004A:  GOTO   025
.................... int16 read_adc_average(int8 channel) { 
.................... 	int16 value; 
.................... 	int8 i; 
....................  
.................... 	set_adc_channel(channel);  
*
0065:  RLF    3F,W
0066:  MOVWF  20
0067:  RLF    20,F
0068:  MOVLW  FC
0069:  ANDWF  20,F
006A:  MOVF   1F,W
006B:  ANDLW  C3
006C:  IORWF  20,W
006D:  MOVWF  1F
.................... 	value=0; 
006E:  CLRF   41
006F:  CLRF   40
.................... 	for ( i=0 ; i<8 ; i++ ) { 
0070:  CLRF   42
0071:  MOVF   42,W
0072:  SUBLW  07
0073:  BTFSS  03.0
0074:  GOTO   086
.................... 		value += read_adc();  
0075:  BSF    1F.1
0076:  BTFSC  1F.1
0077:  GOTO   076
0078:  BSF    03.5
0079:  MOVF   1E,W
007A:  BCF    03.5
007B:  ADDWF  40,F
007C:  MOVF   1E,W
007D:  BTFSC  03.0
007E:  INCFSZ 1E,W
007F:  ADDWF  41,F
.................... 		delay_ms(20); 
0080:  MOVLW  D0
0081:  MOVWF  20
0082:  DECFSZ 20,F
0083:  GOTO   082
.................... 	} 
0084:  INCF   42,F
0085:  GOTO   071
.................... 	/* divide by 8 */ 
.................... 	value = value / 8; 
0086:  RRF    41,F
0087:  RRF    40,F
0088:  RRF    41,F
0089:  RRF    40,F
008A:  RRF    41,F
008B:  RRF    40,F
008C:  MOVLW  1F
008D:  ANDWF  41,F
....................  
.................... 	return value; 
008E:  MOVF   40,W
008F:  MOVWF  21
0090:  MOVF   41,W
0091:  MOVWF  22
.................... } 
0092:  RETLW  00
....................  
.................... int16 read_eeprom_int16(int8 address) { 
.................... 	return make16(read_eeprom(address),read_eeprom(address+1)); 
*
004B:  MOVF   40,W
004C:  BSF    03.5
004D:  MOVWF  1B
004E:  BCF    1C.7
004F:  BSF    1C.0
0050:  MOVF   1A,W
0051:  BCF    03.5
0052:  MOVWF  41
0053:  MOVLW  01
0054:  ADDWF  40,W
0055:  MOVWF  42
0056:  MOVF   42,W
0057:  BSF    03.5
0058:  MOVWF  1B
0059:  BCF    1C.7
005A:  BSF    1C.0
005B:  MOVF   1A,W
005C:  BCF    03.5
005D:  MOVWF  42
005E:  MOVF   41,W
005F:  MOVWF  23
0060:  MOVF   42,W
0061:  MOVWF  21
0062:  MOVF   23,W
0063:  MOVWF  22
.................... } 
0064:  RETLW  00
....................  
.................... void get_threshold(void) { 
.................... 	int8 sw; 
....................  
.................... 	/* read our DIP switches */ 
.................... 	sw=!input(SW0); 
*
00C9:  CLRF   3E
00CA:  BTFSS  05.1
00CB:  INCF   3E,F
.................... 	sw=sw<<1; 
00CC:  BCF    03.0
00CD:  RLF    3E,F
.................... 	sw |= !input(SW1); 
00CE:  MOVLW  00
00CF:  BTFSS  05.2
00D0:  MOVLW  01
00D1:  IORWF  3E,F
....................  
.................... 	configuration_lvd = read_eeprom_int16(EE_LVD+sw*2); 
00D2:  BCF    03.0
00D3:  RLF    3E,W
00D4:  MOVWF  3F
00D5:  MOVWF  40
00D6:  CALL   04B
00D7:  MOVF   22,W
00D8:  MOVWF  30
00D9:  MOVF   21,W
00DA:  MOVWF  2F
.................... 	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2); 
00DB:  BCF    03.0
00DC:  RLF    3E,W
00DD:  ADDLW  08
00DE:  MOVWF  3F
00DF:  MOVWF  40
00E0:  CALL   04B
00E1:  MOVF   22,W
00E2:  MOVWF  32
00E3:  MOVF   21,W
00E4:  MOVWF  31
....................  
.................... 	/*  
.................... 	check if we have a 12/24V configuration. If we do, then we check voltage and determine if we have 12 volt or 24 volt battery. 
.................... 	If 24 volts battery, we double our LVD and LVR set points  
.................... 	*/ 
.................... 	if ( SN_12V_24V == read_eeprom(EE_MODEL) && read_adc_average(VSENSE_ADC) > 615 ) { 
00E5:  MOVLW  1B
00E6:  BSF    03.5
00E7:  MOVWF  1B
00E8:  BCF    1C.7
00E9:  BSF    1C.0
00EA:  MOVF   1A,W
00EB:  SUBLW  02
00EC:  BTFSS  03.2
00ED:  GOTO   119
00EE:  MOVLW  07
00EF:  BCF    03.5
00F0:  MOVWF  3F
00F1:  CALL   065
00F2:  MOVF   22,W
00F3:  MOVWF  40
00F4:  MOVF   21,W
00F5:  MOVWF  3F
00F6:  MOVF   40,W
00F7:  SUBLW  01
00F8:  BTFSS  03.0
00F9:  GOTO   0FC
00FA:  BSF    03.5
00FB:  GOTO   119
00FC:  XORLW  FF
00FD:  BTFSS  03.2
00FE:  GOTO   105
00FF:  MOVF   3F,W
0100:  SUBLW  67
0101:  BTFSS  03.0
0102:  GOTO   105
0103:  BSF    03.5
0104:  GOTO   119
.................... 		configuration_lvd *= 2; 
0105:  BCF    03.0
0106:  RLF    2F,F
0107:  RLF    30,F
.................... 		configuration_lvr *= 2; 
0108:  BCF    03.0
0109:  RLF    31,F
010A:  RLF    32,F
....................  
.................... 		/* turn on LED for 900 milliseconds and then off for 100 ... next we will do normal startup LED flashes */ 
.................... 		restart_wdt(); 
010B:  CLRWDT
.................... 		output_high(LED_STATUS); 
010C:  BSF    07.5
.................... 		delay_ms(900); 
010D:  MOVLW  04
010E:  MOVWF  3F
010F:  MOVLW  E1
0110:  MOVWF  41
0111:  CALL   093
0112:  DECFSZ 3F,F
0113:  GOTO   10F
.................... 		output_low(LED_STATUS); 
0114:  BCF    07.5
.................... 		delay_ms(100); 
0115:  MOVLW  64
0116:  MOVWF  41
0117:  CALL   093
0118:  BSF    03.5
0119:  NOP
.................... 	} 
....................  
....................  
....................  
.................... #ifdef BRECO 
.................... 	sw=!input(SW2); 
.................... 	configuration_lvr = read_eeprom_int16(EE_LVR+sw*2); 
.................... #endif 
.................... } 
....................  
.................... void get_delay(void) { 
.................... 	int8 sw; 
....................  
.................... 	/* read our DIP switches */ 
.................... 	sw=!input(SW2); 
011A:  BCF    03.5
011B:  CLRF   3E
011C:  BTFSS  05.0
011D:  INCF   3E,F
.................... 	sw=sw<<1; 
011E:  BCF    03.0
011F:  RLF    3E,F
.................... 	sw |= !input(SW3); 
0120:  MOVLW  00
0121:  BTFSS  05.5
0122:  MOVLW  01
0123:  IORWF  3E,F
....................  
.................... 	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2); 
0124:  BCF    03.0
0125:  RLF    3E,W
0126:  ADDLW  10
0127:  MOVWF  3F
0128:  MOVWF  40
0129:  CALL   04B
012A:  MOVF   22,W
012B:  MOVWF  34
012C:  MOVF   21,W
012D:  MOVWF  33
....................  
.................... #ifdef BRECO 
.................... 	sw=!input(SW3); 
.................... 	configuration_delay = read_eeprom_int16(EE_DELAY+sw*2); 
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /* setup the PIC */ 
.................... void init_hardware(void) { 
.................... 	/* setup a very slow oscillator - apo3c draws 1.32mA */ 
.................... 	setup_oscillator(OSC_125KHZ); 
*
009F:  MOVLW  11
00A0:  BSF    03.5
00A1:  MOVWF  0F
00A2:  MOVF   0F,W
.................... 	setup_wdt(WDT_OFF); 
00A3:  BCF    03.5
00A4:  BCF    18.0
....................  
.................... //	setup_wdt(WDT_2304MS); 
.................... //	setup_wdt(WDT_2304MS | WDT_ON); 
....................  
.................... 	restart_wdt(); 
00A5:  CLRWDT
....................  
.................... 	/* setup analog to digital converter */ 
.................... 	setup_adc_ports(sAN7); /* battery input */ 
00A6:  BCF    1F.6
00A7:  MOVLW  80
00A8:  BSF    03.5
00A9:  MOVWF  11
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
00AA:  BSF    1F.4
00AB:  BSF    1F.5
00AC:  BCF    1F.6
00AD:  BCF    03.5
00AE:  BSF    1F.7
00AF:  BSF    1F.0
....................  
.................... 	/* turn analog comparator off */ 
.................... 	setup_comparator(NC_NC_NC_NC); 
00B0:  CLRF   1A
00B1:  MOVLW  07
00B2:  MOVWF  19
00B3:  BSF    03.5
00B4:  MOVF   05,W
00B5:  MOVWF  05
00B6:  BCF    03.5
00B7:  MOVF   19,W
00B8:  BCF    0C.3
.................... 	setup_vref(FALSE); 
00B9:  BSF    03.5
00BA:  CLRF   19
....................  
.................... 	/* set the direction of port_a */ 
.................... 	set_tris_a(0b00111111); 
00BB:  MOVLW  3F
00BC:  MOVWF  05
....................     /*           76543210 */ 
....................  
.................... 	/* setup pullups for switches (individually addressable) */ 
.................... 	port_a_pullups(0b00111111); 
00BD:  MOVWF  15
00BE:  BCF    01.7
....................  
.................... 	/* set the direction of port_c */ 
.................... 	set_tris_c(0b00001001); 
00BF:  MOVLW  09
00C0:  MOVWF  07
....................     /*           76543210 */ 
....................  
....................  
.................... 	/* setup our timer to be 1.048576 second */ 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_128); 
00C1:  MOVF   01,W
00C2:  ANDLW  C0
00C3:  IORLW  06
00C4:  MOVWF  01
.................... 	enable_interrupts(INT_TIMER0); 
00C5:  BCF    03.5
00C6:  BSF    0B.5
.................... 	enable_interrupts(GLOBAL); 
00C7:  MOVLW  C0
00C8:  IORWF  0B,F
....................  
.................... 	/* read our configuration from EEPROM */ 
.................... 	get_threshold(); 
.................... 	get_delay(); 
....................  
.................... 	/* initial values */ 
.................... 	output_low(LED_STATUS); 
*
012E:  BCF    07.5
.................... 	output_low(VGOOD); 
012F:  BCF    07.2
.................... 	decide_now=1; 
0130:  MOVLW  01
0131:  MOVWF  2E
.................... } 
0132:  GOTO   173 (RETURN)
....................  
.................... void led_flash(int8 n) { 
.................... 	int8 i; 
.................... 	for ( i=0 ; i<n ; i++ ) { 
0133:  CLRF   3F
0134:  MOVF   3E,W
0135:  SUBWF  3F,W
0136:  BTFSC  03.0
0137:  GOTO   14B
.................... 		restart_wdt(); 
0138:  CLRWDT
.................... 		output_high(LED_STATUS); 
0139:  BSF    07.5
.................... 		delay_ms(500); 
013A:  MOVLW  02
013B:  MOVWF  40
013C:  MOVLW  FA
013D:  MOVWF  41
013E:  CALL   093
013F:  DECFSZ 40,F
0140:  GOTO   13C
.................... 		output_low(LED_STATUS); 
0141:  BCF    07.5
.................... 		delay_ms(500); 
0142:  MOVLW  02
0143:  MOVWF  40
0144:  MOVLW  FA
0145:  MOVWF  41
0146:  CALL   093
0147:  DECFSZ 40,F
0148:  GOTO   144
.................... 	} 
0149:  INCF   3F,F
014A:  GOTO   134
.................... } 
014B:  GOTO   17C (RETURN)
....................  
.................... void main(void) { 
*
015E:  CLRF   04
015F:  MOVLW  1F
0160:  ANDWF  03,F
0161:  MOVLW  11
0162:  BSF    03.5
0163:  MOVWF  0F
0164:  MOVF   0F,W
0165:  BCF    03.5
0166:  BCF    1F.6
0167:  MOVLW  00
0168:  BSF    03.5
0169:  MOVWF  11
016A:  BCF    03.5
016B:  CLRF   1A
016C:  MOVLW  07
016D:  MOVWF  19
.................... 	int16 adc; 
....................  
.................... 	int8  on_delay; 
.................... 	int16 off_delay; 
.................... 	int1 power; 
....................  
.................... 	/* initialize hardware */ 
.................... 	init_hardware(); 
*
0172:  GOTO   09F
....................  
....................  
.................... 	on_delay=ON_DELAY_SECONDS; 
0173:  MOVLW  05
0174:  MOVWF  3A
.................... 	off_delay=configuration_delay; 
0175:  MOVF   34,W
0176:  MOVWF  3C
0177:  MOVF   33,W
0178:  MOVWF  3B
....................  
.................... 	/* flash the LED 5 times on startup ... non-hysteresis APOx firmware flashes 10 times on startup */ 
.................... 	led_flash(5); 
0179:  MOVLW  05
017A:  MOVWF  3E
017B:  GOTO   133
....................  
.................... 	power=0; 
017C:  BCF    3D.0
....................  
.................... 	/* main loop */ 
.................... 	for ( ; ; ) { 
.................... 		restart_wdt(); 
017D:  CLRWDT
....................  
.................... 		/* set the contactor based on previous decision and override switch */ 
.................... 		if ( 1==power ) { 
017E:  MOVLW  00
017F:  BTFSC  3D.0
0180:  MOVLW  01
0181:  SUBLW  01
0182:  BTFSS  03.2
0183:  GOTO   187
.................... 			/* should be on based on voltage / time */ 
.................... 			contactor_on(); 
0184:  CALL   14C
....................  
.................... 			/* no LED blinking required */ 
.................... 			ledBlink=0; 
0185:  CLRF   37
.................... 		} else if ( ! input(SW_OVERRIDE) ) { 
0186:  GOTO   18F
0187:  BTFSC  05.4
0188:  GOTO   18D
.................... 			/* shouldn't be on based on voltage / time, but override switch has us on */ 
.................... 			contactor_on(); 
0189:  CALL   14C
....................  
.................... 			/* blink LED to indicate we are overriden */ 
.................... 			ledBlink=1; 
018A:  MOVLW  01
018B:  MOVWF  37
.................... 		} else { 
018C:  GOTO   18F
.................... 			/* shouldn't be on based on voltage / time */ 
.................... 			contactor_off(); 
018D:  GOTO   155
....................  
.................... 			/* no LED blinking required */ 
.................... 			ledBlink=0; 
018E:  CLRF   37
.................... 		} 
.................... 		 
.................... 		/* determine contactor state for next loop */ 
.................... 		if ( decide_now ) { 
018F:  MOVF   2E,F
0190:  BTFSC  03.2
0191:  GOTO   1D9
.................... 			decide_now=0; 
0192:  CLRF   2E
....................  
.................... 			adc=read_adc_average(VSENSE_ADC); 
0193:  MOVLW  07
0194:  MOVWF  3F
0195:  CALL   065
0196:  MOVF   22,W
0197:  MOVWF  39
0198:  MOVF   21,W
0199:  MOVWF  38
.................... 	 
.................... 			if ( adc > configuration_lvd ) 
019A:  MOVF   30,W
019B:  SUBWF  39,W
019C:  BTFSS  03.0
019D:  GOTO   1A6
019E:  BTFSS  03.2
019F:  GOTO   1A4
01A0:  MOVF   38,W
01A1:  SUBWF  2F,W
01A2:  BTFSC  03.0
01A3:  GOTO   1A6
.................... 				output_high(VGOOD); 
01A4:  BSF    07.2
.................... 			else 
01A5:  GOTO   1A7
.................... 				output_low(VGOOD); 
01A6:  BCF    07.2
.................... 	 
.................... 	 
.................... 			if ( adc > configuration_lvr ) { 
01A7:  MOVF   32,W
01A8:  SUBWF  39,W
01A9:  BTFSS  03.0
01AA:  GOTO   1B9
01AB:  BTFSS  03.2
01AC:  GOTO   1B1
01AD:  MOVF   38,W
01AE:  SUBWF  31,W
01AF:  BTFSC  03.0
01B0:  GOTO   1B9
.................... 				if ( on_delay > 0 ) { 
01B1:  MOVF   3A,F
01B2:  BTFSC  03.2
01B3:  GOTO   1B6
.................... 					on_delay--; 
01B4:  DECF   3A,F
.................... 				} else { 
01B5:  GOTO   1B8
.................... 					power=1; 
01B6:  BSF    3D.0
.................... 					output_low(LED_STATUS); 
01B7:  BCF    07.5
.................... 				} 
.................... 			} else { 
01B8:  GOTO   1BB
.................... 				on_delay = ON_DELAY_SECONDS; /* 5 seconds before re-connecting */ 
01B9:  MOVLW  05
01BA:  MOVWF  3A
.................... 			} 
.................... 		 
.................... 			if ( adc < configuration_lvd ) { 
01BB:  MOVF   39,W
01BC:  SUBWF  30,W
01BD:  BTFSS  03.0
01BE:  GOTO   1D4
01BF:  BTFSS  03.2
01C0:  GOTO   1C5
01C1:  MOVF   2F,W
01C2:  SUBWF  38,W
01C3:  BTFSC  03.0
01C4:  GOTO   1D4
.................... 				if ( off_delay > 0 ) { 
01C5:  MOVF   3B,F
01C6:  BTFSS  03.2
01C7:  GOTO   1CB
01C8:  MOVF   3C,F
01C9:  BTFSC  03.2
01CA:  GOTO   1D1
.................... 					off_delay--; 
01CB:  MOVF   3B,W
01CC:  BTFSC  03.2
01CD:  DECF   3C,F
01CE:  DECF   3B,F
.................... 					output_high(LED_STATUS); 
01CF:  BSF    07.5
.................... 				} else { 
01D0:  GOTO   1D3
.................... 					power=0; 
01D1:  BCF    3D.0
.................... 					output_low(LED_STATUS); 
01D2:  BCF    07.5
.................... 				} 
.................... 			} else { 
01D3:  GOTO   1D8
.................... 				off_delay = configuration_delay; 
01D4:  MOVF   34,W
01D5:  MOVWF  3C
01D6:  MOVF   33,W
01D7:  MOVWF  3B
.................... 			} 
.................... 			restart_wdt(); 
01D8:  CLRWDT
.................... 		} 
.................... 	} 
01D9:  GOTO   17D
.................... } 
01DA:  GOTO   1DA

Configuration Fuses:
   Word  1: 30D4   INTRC_IO NOPROTECT NOBROWNOUT NOMCLR NOCPD NOWDT NOPUT NOIESO NOFCMEN

ROM data:
002100: 0001 0088 0001 0091 0001 0099 0001 00A2 
002108: 0001 0099 0001 00A2 0001 00AA 0001 00AE 
002110: 0000 0001 0001 002C 0002 0058 0004 00B0 
002118: 0000 0000 0000 0002 
